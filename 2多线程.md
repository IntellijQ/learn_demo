# 多线程
- ## **计算机组成原理**
    * #### 计算机组成
            1.USB 显卡 网卡驱动 磁盘
            2.内存
            3.CPU(速度快于内存近100倍)
                3.1.ALU 计算单元
                3.2.Registers
                3.3.PC 程序计数器（存放指令，用来标记线程运行的结点）
                3.4.Cache
            4.内存总线
            5.系统总线
            6.IO总线
            7.IO Bidge
    * #### 数据交互方式
            1.首先对应的 进程 将 指令+数据 加载到 内存 
            2.然后对应的 线程 通过 总线 把 指令+数据 传到 CPU
            3.然后在CPU中，指令放到PC，数据放到Registers
            4.最后CPU把计算好的结果返回到内存中     
    - ## 缓存
        + #### 发展由来
                介于CPU和内存
                因为ALU（计算单元）到内存的时间太慢，效率低
                所以出现3级缓存
                在获取数据的时候：依次L1 L2 L3
        + #### 缓存分类
               3级缓存：L1 L2 L3
               多核CPU的情况：
                    每颗CPU上的每个核分别包含L1 L2 级别的缓存
                    每颗CPU上的多核共享L3级别的缓存         
        + #### 缓存行
               背景：正常从内存读取数据的时候，可以按照逐字节或者逐位读取，这样会有严重性能问题
               解决方案：按块读取
               解决方案理论：根据程序局部性原理，可以提高效率，充分发挥总线CPU针脚等一次性读取更多数据的能力
               缓存行数据长度：64个字节
               
        + #### 缓存一致性协议
                概念：CPU为了保证各个缓存行的数据一致性，而采取的协议
                实现方式：
                    1.英特尔：MESI (Modified-修改 Exclusive-独占 Shard-共享 Invalid-失效)
                缓存行的四种状态：
                    Modified-修改 Exclusive-独占 Shard-共享 Invalid-失效
        + #### 缓存锁
                实现方式：
                    1.有些无法被缓存的数据 或者 跨越多个缓存行的数据 必须使用总线锁       
                    
                    
- ## **进程/线程**
        进程：资源分配的最小单位
        线程：程序运行的最小单位
***

- ## **锁**
    + #### 锁的概念
            多线程访问数据，为了保证一致性，因此诞生了锁
    + #### 锁状态
            无锁状态    01
            偏向锁状态  01
            自旋锁装    00
            重量级状态  10 
            GC标记状态  11
    + #### 锁类型（自上而下进行升级）
            用户空间锁：
                1.偏向锁状态
                    ①.概念：
                        1.偏向锁不是一种锁
                        2.第一个线程通过ID打标签的方式使用偏向锁
                        3.只要有大于1个线程获取锁的时候，会进行锁升级CAS--重量级锁
                        默认延时4s 
                        可以通过参数改变 -XX:BiasedLockingStartupDelay=0
                    ②.为什么使用偏向锁：
                        0.Vector StringBuffer 很多方法都被synchronized修饰，70%以上的时间 只有一个线程竞争锁
                        1.假如有一把锁，只要被synchronized修饰，就会触发锁的竞争机制，如果绝大多数情况只有一个线程使用，那么会浪费时间
                    【注】：
                        1.如果计算过对象的hashcode，则对象无法进入偏向状态 
                        2.在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，
                            发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销，
                            这时我们可以通过添加 JVM 参数关闭偏向锁来调优系统性能  
                            -XX:-UseBiasedLocking //关闭偏向锁（默认打开）
                            或者
                            -XX:+UseHeavyMonitors  //设置重量级锁 
                2.自旋锁
                    CAS实现
            重量级锁：申请锁资源必须通过操作系统内核调度
    - #### 面试问题
             
***  
- ## **CAS**
    + #### **compare and swap**
    + #### **实现逻辑**
            读取当前值E
            计算结果值V
            比较E和当前最新值N是否相等
            如果相等，更新为新值V
            如果不相等，更新为新值V，继续循环读取当前值E
    + #### **CAS的问题**
            1.解决ABA问题：增加版本号
            2.保证CAS原子性：
                汇编指令：LOCK_IF_MP 和 cmpxchgl
                         MP含义：multi processors 多核
                最终实现：cmpxchg=cas修改变量值 
                         即指令：lock cmpxchg
                         lock含义：lock指令在执行后面指定的时候锁定一个北桥信号（不采用锁总线的方式）
                         
- ## **对象的内存布局** 
     + #### 内存布局
            markword   8个字节 = 64位
                最低两位：表示锁状态
            classpoint 默认压缩指针 4个字节
            data数据
            padding
     + #### markword细节
            锁信息
            GC信息
            HASHCODE
                               
                         
- ## **synchronized**
    + #### 不同版本的JDK，导致synchronized锁类型也不一样
            JDK1.4之前：
                synchronized：重量级锁（因为申请锁资源必须通过操作系统内核调度）
            JDK1.5之后：
                synchronized：会进行锁升级过程
    - #### 实现逻辑
            1.JVM 中的同步是基于进入和退出管程（Monitor）对象实现的
                monierenter
                monierexit
            2.底层汇编指令 lock cmpxchg
    - #### 锁升级过程
            ①当一个线程获取锁时，首先对象锁将成为一个偏向锁，这样做是为了优化同一线程重复获取导致的用户态与内核态的切换问题；
            ②其次如果有多个线程竞争锁资源，锁将会升级为轻量级锁，它适用于在短时间内持有锁，且分锁有交替切换的场景；
                轻量级锁还使用了自旋锁来避免线程用户态与内核态的频繁切换，大大地提高了系统性能；
            ③但如果锁竞争太激烈了，那么同步锁将会升级为重量级锁。
            
           【注】减少锁竞争，是优化 Synchronized 同步锁的关键。
                ①我们应该尽量使 Synchronized 同步锁处于轻量级锁或偏向锁，这样才能提高 Synchronized 同步锁的性能；
                ②通过减小锁粒度来降低锁竞争也是一种最常用的优化方法；
                另外我们还可以通过减少锁的持有时间来提高 Synchronized 同步锁在自旋时获取锁资源的成功率，
                避免 Synchronized 同步锁升级为重量级锁。
            
    - #### 面试问题
            1.synchronized(0)是什么锁？
                            默认是00-轻量级锁
                            因为JVM虚拟机自己有一些默认启动的线程，里面有很多sync代码，这些sync代码启动的时候肯定会有竞争，
                            如果还使用偏向锁，就会造成锁不断的撤销和升级的操作，效率较低
            2.自旋锁什么时候升级为重量级锁
                
            3.为什么又自旋锁还需要重量级锁
                ①自旋锁是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗
                ②重量级锁有等待队列，所以拿不到锁的进入队列，不需要消耗CPU资源
                【注】
                    在高负载、高并发的场景下，我们可以通过设置 JVM 参数来关闭自旋锁，优化系统性能
                    -XX:-UseSpinning //参数关闭自旋锁优化(默认打开) 
                    -XX:PreBlockSpin //参数修改默认的自旋次数。JDK1.7后，去掉此参数，由jvm控制
                    
            4.偏向锁是否一定比自旋锁效率高
                不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁
                            JVM启动过程中，会有很多线程竞争，所以默认启动时不打开偏向锁，过一段时间再打开
           5.轻量级锁重量级锁的hashCode存在什么地方
                           线程栈中，轻量级锁LR中，或是代表重量级锁的ObjectMonitor的成员中
                           


- ## **Volatile**  
    + #### **线程可见性** 
            参考：com.learn.jvm.thread.volatile1.VolatileTest
    + #### **指令乱序**
            概念：CPU执行的速度很快，为了优化执行效率，可能导致前后两条指令乱序
            什么时候指令乱序：
                hanppens-before原则 8条 之外的规则，都可重排
            As-if-serial:不管如何重排序，单线程执行结果不会改变   
                
    + #### **如何阻止乱序，同时使线程可见性的**
            JVM级别的内存屏障：只是一个规范 LoadLoad StoreStore LoadStore StoreLoad
                因此volatile必须实现JVM对应的规范：
                    volatile写：在前增加StoreStore，在后增加StoreLoad
                    volatile读：在后增加LoadLoad，或者 在后增加LoadStore
                实际实现的方式是：
                    通过lock addl
                        lock指令：用于在多处理器中执行指令时对共享内存的独占使用
                        它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效
                        另外还提供了有序的指令无法越过这个内存屏障的作用
                    为什么会这样？主要是hotspot偷懒了，没有针对不同的处理器进行细化操作
            硬件级别的内存屏障：
                sfence：写屏障
                ifence：读屏障
                mfence：读写屏障
            
                    
    
           
          
            
       
      