# 数据结构
- ## **链表**
   + `双链表`
   + `约瑟夫问题`
***

- ## **队列**
   + `消息队列`
***

- ## **栈**
   + `逆波兰计算器`
***

- ## **递归**
   + `阶乘`
   + `斐波那契数列`
   + `八皇后问题`
***

- ## **排序算法**
    - #### ***内部排序***
        - ##### ***插入排序***
            - ###### ***直接插入排序(平均n^2-稳定-最差n^2)***
                    把n个元素看成一个有序表和一个无序表,
                    通过构建有序表，对于未排序数据，在已排序表中从后向前扫描，找到相应位置并插入。
            - ###### ***希尔排序(平均nlogn-不稳定-最差nlogn^2)***
                    把n个元素按下标进行增量m的分组，对每组使用直接插入排序；
                    随着增量m的减少，每组包含的元素越来越多，当m=1时，算法终止。
                    
        - ##### ***选择排序***
            - ###### ***简单选择排序(平均n^2-不稳定-最差n^2)***
                    首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置,
                    然后，再从剩余未排序元素中继续寻找最小（大）元素，
                    然后放到已排序序列的末尾，
                    以此类推，直到所有元素均排序完毕。
            - ###### ***堆排序(平均nlogn-不稳定-最差nlogn^2)***
                    构建最大（小）顶堆，然后排序。
                    
        - ##### ***交换排序***
            - ###### ***冒泡排序(平均n^2-稳定-最差n^2)***
                    通过对待排序元素从前向后看，依次比较相邻元素的至，
                    若发现逆序则交换，使值较大的元素逐渐从前向后移动。
            - ###### ***快速排序(平均nlogn-不稳定-最差n^2)***
                    该算法是对冒泡排序的一种改进，
                    基本思想是：
                    通过一趟排序将要排序的数据分割成独立的两部分，
                    其中一部分的所有数据都比另外一部分的所有数据都要小，
                    然后按照此方法对这两部分数据分别进行快速排序，
                    整个排序过程可以递归进行，以此达到整个数据变成有序序列。
                    
        - ##### ***归并排序***
            - ###### ***归并排序(平均nlogn-稳定-最差nlogn)***
                    该算法采用经典的分治策略：分而治之，将问题分成小问题，然后递归求解。
                    
        - ##### ***基数排序***
             - ###### ***基数排序（平均nk-稳定-最差nk） k：桶的数量***
                    该算法属于分配式排序 ，又称桶子法，它是通过键值的各个位的值，将要排序的元素分配值 预定的桶中。
   + 外部排序
***    


- ## **查找算法**
    + 线性查找：`for循环遍历`
    + 二分查找：`①数组需有序;
                ②通过查询中间位置mid= (left + hight) /2`
    + 插值查找：`①数组需有序;
                ②通过查询自适应位置mid=left + (right - left) *(target - array[left]) / (array[right] - array[left]);
                ③数据分布比较均匀且数据量较大的时候，会比二分查找性能好
                `
    + 斐波那契查找
***    

- ## **二叉树**
  #### 二叉树遍历
        1. 前序遍历：
        2. 中序遍历：
        3. 后续遍历：
        
  #### 赫夫曼树
        0.概念：（也就是带权路径长度最小的二叉树）
            ①给定n个权值作为n个叶子节点，构造一棵二叉树，若概述的带权路径长度达到最小，
             称这样的二叉树为最优二叉树，也就是哈夫曼树
            ②哈夫曼树是带权路径长度最短的树，权值较大的结点离根越近
        1.路径和路径长度:
            ①路径：在一颗树中，从一个结点往下可以到达的孩子或孙子结点之间的通路
            ②路径长度：通路中分支的数目称为路径长度，若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
        2.结点的权和带权路径长度：
            ①若将树中结点赋给一个有着魔种含义的数值，则这个数值成为该结点的权
            ②带权路径长度:从根结点到该结点之间的路径长度与该结点的权的乘积
            ③树的带权路径长度(weighted path length = WPL)：所有叶子结点的带权路径长度之和，权值越大的结点离根结点越近的二叉树才是最优二叉树
        3.构建步骤
            ①. 将数组从小到大排序，每个节点都是单独的一颗二叉树
            ②. 取出根节点权值最小的两颗二叉树
            ③. 组成一颗新的二叉树，这颗树的根节点 等于 前两颗二叉树 根节点之和
            ④. 将这颗新的二叉树的根节点，放到剩余的节点中，进行重新排序，不断重复①②③步骤，直至数组为空
  
  #### 二叉排序树
        0.引入二叉排序树概念问题：如何进行高效添加和查询数据
            ①数组：查询快，但是添加慢（移动或者扩容）
            ②链表：添加快，但是查询慢
            综上以上两种方式不能很好的解决问题，由此二叉排序树应运而生
        1.概念：BST(binary search （sort） tree),对于二叉排序树的任何一个非叶子结点，都要求其左孩子小于该结点，右孩子大于该结点
        
  #### 二叉平衡树
        0.引入二叉排序树概念问题：如何进行高效添加和查询数据
            ①数组：查询快，但是添加慢（移动或者扩容）
            ②链表：添加快，但是查询慢
            综上以上两种方式不能很好的解决问题，由此二叉排序树应运而生
        1.概念：BST(binary search （sort） tree),对于二叉排序树的任何一个非叶子结点，都要求其左孩子小于该结点，右孩子大于该结点
*** 

- ## **图**
  #### 图创建
        d
  #### 图遍历
        1. 深度遍历： https://www.cnblogs.com/nr-zhang/p/11236369.html
        2. 广度遍历：
***

- ## **常用算法**
  #### 分治算法
        0.汉诺塔问题
        
  #### 动态规划
        0.背包问题
            ①填表法
        1. 解决字符串匹配
            ①暴力匹配
            ②KMP
                1.对于T子串不重复访问字符，即每次比较都是从T的失效位开始的 
                2.在P中，0到i位的前缀找最大相同前后缀串位数是为了第i+1位失配时找P的匹配位x，
                假设从P的x位开始匹配，那么P的0到x-1位与T的失配位往前数x位必须是一样的，
                就是P的最大相同前缀和后缀，这就是前缀表。两者联系一下就是这个算法啦
        2. ：
   https://zhuanlan.zhihu.com/p/105467597             
  #### 动态规划：
  #### 动态规划：
  #### 动态规划：
***


# spring

# mysql

完善中。。。
