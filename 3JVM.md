# JVM虚拟机

- ## **一、JVM与Java体系结构**
    + ### JVM架构模型
        * #### 基于栈的指令集架构
                ①.实现简单，使用于资源受限的系统
                ②.避开了寄存器的分配难题：使用零地址指令方式分配
                ③.指令流中的指令大部分时零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
                ④.不需要硬件支持，可移植性更好，更好实现
        * #### 基于寄存器的指令集架构
                ①指令简单
    + ### **JVM的生命周期** 
        * #### 虚拟机的启动 
                Java虚拟机的启动时通过引导类加载器创建一个初始类来完成的，这个类时由虚拟机的具体实现指定的。      
        * #### 虚拟机的执行
                执行一个所谓的Java程序的时候，实际执行的是Java虚拟机的进程
        * #### 虚拟机的终止
                ①程序正常/异常退出
                ②操作系统错误导致java进程结束
                ③通过exit方法退出
                   
- ## **二、类加载子系统**
    + ### 概念
            1.类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识
            2.ClassLoader负责class文件的加载，Execution Engine负责运行
            3.加载的类信息存在在方法区，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（常量信息是class问家中常量池部分的内存映射）
            
- ## **三、运行时数据区概述及线程**
- ## **四、程序计数器**
- ## **五、虚拟机栈**
- ## **六、本地方法接口**
- ## **七、本地方法栈**
- ## **八、堆**
- ## **九、方法区**
- ## **十、直接内存**
- ## **十一、执行引擎**
- ## **十二、StringTable**
- ## **十三、垃圾回收概述**
- ## **十四、垃圾回收相关算法**
- ## **十五、垃圾会后相关概念**
- ## **十六、垃圾回收器**



内存泄漏：
    占用内存一直未释放
内存溢出：    
    越来越多的内存泄露 最终会导致 内存溢出
    
什么是垃圾：
    没有任何引用指向的一个对象或多个对象
         
如何定位垃圾：
    1.引用计数算法（比如循环引用，但是在内存中无任何）
    2.根可达算法
        根对象包括：
            JVM虚拟机栈、本地方法栈、方法区的静态引用、常量池、Clazz对象
            
常用的垃圾算法：
     1.Mark-Sweep 标记清除
        产生碎片，位置不连续
     2.Copying 拷贝
        没有碎片，浪费空间
     3.Mark-Compact 标记压缩
        没有碎片，效率低      
    
JVM内存分代模型
    1.部分垃圾回收器使用的模型
    2.新生代+老年代+元数据区（1.8）/永久代（1.7）           
          
            
       
      