# JAVA基础知识汇总
- ## **数据类型**
   
***

- ## **String特性**
   
***  
   
- ## **Integer特性**
  
***

- ## **Hashmap特性**
    + ### `参数定义`
      * 容量
        #####
            // 1. 容量（capacity）： HashMap中数组的长度
            // a. 容量范围：必须是2的幂 & <最大容量（2的30次方）
            // b. 初始容量 = 哈希表创建时的容量
              // 默认容量 = 16 = 1<<4 = 00001中的1向左移4位 = 10000 = 十进制的2^4=16
              static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
              // 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）
              static final int MAXIMUM_CAPACITY = 1 << 30;
       * 加载因子
        #####
            // 2. 加载因子(Load factor)：HashMap在其容量自动增加前可达到多满的一种尺度
            // a. 加载因子越大、填满的元素越多 = 空间利用率高、但冲突的机会加大、查找效率变低（因为链表变长了）
            // b. 加载因子越小、填满的元素越少 = 空间利用率小、冲突的机会减小、查找效率高（链表不长）
              // 实际加载因子
              final float loadFactor;
              // 默认加载因子 = 0.75
              static final float DEFAULT_LOAD_FACTOR = 0.75f;
       * 扩容阈值
        #####
            // 3. 扩容阈值（threshold）：当哈希表的大小 ≥ 扩容阈值时，就会扩容哈希表（即扩充HashMap的容量） 
            // a. 扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数
            // b. 扩容阈值 = 容量 x 加载因子
              int threshold;
              
       * 存储数据参数
        #####
           [注]详见各个版本
           
       * 面试问题：
        ##### 问题1：为什么不直接采用经过hashCode（）处理的哈希码 作为 存储数组table的下标位置？
              结论：容易出现 哈希码 与 数组大小范围不匹配的情况，即 计算出来的哈希码可能 不在数组大小范围内，从而导致无法匹配存储位置
                   为了解决 “哈希码与数组大小范围不匹配” 的问题，HashMap给出了解决方案：哈希码 与运算（&） （数组长度-1）
        ##### 问题2：为什么采用 数组长度 2的N次幂 要求？
              结论：1.计算数组下标的公式：哈希码 与运算(&) （数组长度-1）
                   2.偶数-1是奇数，二进制后，为011....11的格式;
                     奇数-1是偶数，二进制后，为000....00的格式
                   3.因为&运算，有0参与就是0，为了尽可能保证了哈希参与运算，从而保证了数据的均匀性，降低哈希冲突
        ##### 问题3：为什么采用 哈希码 与运算(&) （数组长度-1） 计算数组下标？
              结论：1.解决 “哈希码与数组大小范围不匹配” 的问题
                   2.与运算，在该公式中，数组长度需为 2的N次幂，从而等价于一个% 取余运算，但是与运算的效率高，所以选择了与运算
                   3.保证了数据的均匀性，降低哈希冲突
        ##### 问题4：为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？
              结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 & 均匀性，最终减少Hash冲突
    + ### `1.7版本`
       * 存储数据参数
           #####
               // 存储数据的Entry类型 数组，长度 = 2的幂
               // HashMap的实现方式 = 拉链法，Entry数组上的每个元素本质上是一个单向链表
               transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;  
               // HashMap的大小，即 HashMap中存储的键值对的数量
               transient int size; 
        * 存储结构
            ##### 
                数组 + 链表
        * hash及定位数组下标方式
            ##### 
                1.hash方式：使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）
                static final int hash(int h) {
                        h ^= k.hashCode(); 
                        h ^= (h >>> 20) ^ (h >>> 12);
                        return h ^ (h >>> 7) ^ (h >>> 4);
                }
            ##### 
                2.定位数组下标：(数组长度-1) & hash
                 static int indexFor(int h, int length) {  
                          return h & (length-1);
                 }
        * put方式
            #####
                1.采取链表头插入 
                2.无hash冲突时，放到数组中
                3.有hash冲突时，放到链表头部
        * 扩容机制
            ##### 
               1.发生hash碰撞且数组长度大于扩容值
               2.数组长度=原数组长度*2；容量=原容量*2
               3.扩容后，可能导致链表和之前顺序相反，可能导致环形链表致使死锁
        * 注意事项
            ##### hashmap的size大于容量，是否一定会扩容，为什么？
                1.put数据时，比如 默认大小为16，负载因子0.75，阈值12，可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象。
                    原因：前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。
                2.put数据时，比如 默认大小为16，负载因子0.75，阈值12，可能 超多16个值都还没有扩容。（为扩容前最多可以存26个值）
                    原因：前11个值全部hash碰撞，
                        存到数组的同一个位置（这时元素个数小于阈值12，不会扩容），
                        后面所有存入的15个值全部分散到数组剩下的15个位置（这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash碰撞，所以不会扩容），
                        前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。
            
    + ### `1.8版本`
       * 存储数据参数
           #####
              // 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表
              transient Node<K,V>[] table;
              // HashMap的大小，即 HashMap中存储的键值对的数量
              transient int size;
             
              /** 
               * 与红黑树相关的参数
               */
               // 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 > 该值时，则将链表转换成红黑树
               static final int TREEIFY_THRESHOLD = 8; 
               // 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 < 6时，则将 红黑树转换成链表
               static final int UNTREEIFY_THRESHOLD = 6;
               // 3. 最小树形化容量阈值：即 当哈希表中的容量 > 该值时，才允许树形化链表 （即 将链表 转换成红黑树）
               // 否则，若桶内元素太多时，则直接扩容，而不是树形化
               // 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
               static final int MIN_TREEIFY_CAPACITY = 64;
  
        * 存储结构
            ##### 
                数组 + 链表 + 红黑树
        * hash及定位数组下标方式
            ##### 
                1.hash方式：使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）
                static final int hash(Object key) {
                        int h;
                        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
                }
            ##### 
                2.定位数组下标：(数组长度-1) & hash
                (n - 1) & hash
        * put方式
            #####
                1.采取链表尾插入
                2.无冲突时，存放到数组中
                3.有冲突&链表长度<8时，存放到链表尾部
                4.有冲突&链表长度>8时，存放到链红黑树
        * 扩容机制
            ##### 
                1.待转移数据的hash & 原数组长度 == 0，则放到 原位置
                1.待转移数据的hash & 原数组长度 != 0，则放到 原位置 + 原数组长度