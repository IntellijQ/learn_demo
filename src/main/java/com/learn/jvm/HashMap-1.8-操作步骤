1.HashMap的数据结构


2.计算hash算法
    h = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    右位移16位，正好是32bit的一半，
    自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。
    而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

3.计算下标
    i = (n - 1) & hash]
    顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整数幂。
    因为这样（数组长度-1）正好相当于一个“低位掩码”。
    “与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。
    以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。
    和某散列值做“与”操作如下，结果就是截取了最低的四位值。


4.put逻辑
  4.1 判断是否为空，为空则扩容，默认数组.length=16,容量为16*0.75=12
      得到 Node<K,V> p = tab[i = (n - 1) & hash]
  4.2